给定一个无序的整数数组，找到其中最长上升(这里是严格上升)子序列的长度。

示例:

输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
说明:

可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n2) 。
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?


//暴力dp算法
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {

    	int n = nums.size();
    	if(n == 0)
    		return 0;
    	int ret = 0;
    	vector<int> dp(n,1);
    	for(int i = 0;i < n;i++)
    	{
    		for(int j = 0;j < i;j++)
    		{
    			if(nums[i] > nums[j])
    				dp[i] = max(dp[i],dp[j]+1);
    		}
    		if(dp[i] > ret)
    			ret = dp[i];
    	}
    	return ret;        
    }
};



//方法2：贪心算法+二分查找
/*
还是想一下“人工”做这个题是什么过程。按照上面的例子来分析：
首先看到10，加入备选集，备选集合为{10}；
之后看到了9，没有形成上升序列，那么9不应该加入备选集合。但是因为9小于10，
所以如果把10替换成9会增加接下来产生上升序列的机会，且并不影响备选集合元素的个数（因为是替换），
所以替换掉，备选集现在有{9}；
遇到2道理同上，替换掉9，备选集变成{2}；
遇到5，这时候形成了上升序列，此时应该是添加到备选集合，变为{2,5}；
遇到3，没有形成上升序列，但还是道理同加入9的情况，如果此时把5替换成3，
会增加接下来形成上升序列的机会，且备选集保持上升，并且个数也没变，所以替换掉5，备选集变成{2,3}；
遇到7，同遇到5，添加元素，备选集{2,3,7}；
遇到101，同上，备选集{2,3,7,101}；
遇到18，还是一样，虽然没有形成上升序列，但是如果把101替换掉，那么接下来形成上升序列的机会会增加，
并且备选集的上升属性和元素个数都不变，所以替换，备选集变为{2,3,7,18}。
至此所有元素添加完毕，备选集的元素个数就是最长上升子序列长度。但这里注意，
备选集里面的元素并不是最后最长子序列的元素。因为在寻找最长子序列的过程中，
目标是尽可能的让以后形成上升序列的机会增加，所以进行了替换。
“人工”做出来之后，只要用程序实现思考过程就好。总结起来就是：
如果遇到的元素比备选集合里面的元素都大，那么就添加进去，使得上升序列长度增加；
如果遇到的元素比备选集合里最后一个元素小，那么代表它无法被添加到备选集。
但是为了使后面得到上升序列的机会增加，需要在不破坏集合上升属性和元素总数的情况下，
替换掉备选集中的元素，那么就是替换掉大于他的元素中最小的那个，这样才能满足条件。
这时候，发现备选集一直是保持有序，寻找替换元素的时候就可以用到二分查找，
得到O(nlogn)的时间复杂度。其中还要注意的是如果元素已经在备选集合中，
是不需要任何操作的，因为它并不能增加上升序列的长度，
也不会增加之后遇到上升序列的机会，所以直接跳过。
这个做法的精髓是即使用小的元素替换掉中间的元素，
备选集的大小不变，还是原来的大小，


思路是，我们先建立一个数组 ends，把首元素放进去，然后比较之后的元素，
如果遍历到的新元素比ends数组中的首元素小的话，替换首元素为此新元素，
如果遍历到的新元素比ends数组中的末尾元素还大的话，将此新元素添加到ends数组末尾(注意不覆盖原末尾元素)。
如果遍历到的新元素比ends数组首元素大，比尾元素小时，此时用二分查找法找到第一个不小于此新元素的位置，
覆盖掉此位置的原来的数字，
以此类推直至遍历完整个nums数组，此时ends数组的长度就是我们要求的 LIS 的长度，
特别注意的是ends数组的值可能不是一个真实的LIS，比如若输入数组nums为 {4, 2， 4， 5， 3， 7}，
那么算完后的ends数组为{2， 3， 5， 7}，可以发现它不是一个原数组的LIS，只是长度相等而已，千万要注意这点。

*/



//和上面的思路一样，但是是从动态规划的角度去理解解题思路
/*
使用一个数组dp保存信息，穷举到达nums当前位置时子序列长度的情况，
上升递增子序列长度为1，长度为2，长度为3，...,
以及当前位置所能达到的最长递增子序列的长度
dp[i]: 所有长度为i+1的递增子序列中, 最小的那个序列尾数.
由定义知dp数组必然是一个递增数组(长度为i+1的递增子序列由一个长度为i的递增子序列+一个大于这个长度为i
的子序列的尾数的元素组成), 可以用ret来表示最长递增子序列的长度. 
对数组进行迭代, 依次判断每个数num将其插入dp数组相应的位置:
1. num > dp[ret], 表示num比所有已知递增序列的尾数都大, 将num添加入dp
数组尾部, 并将最长递增序列长度ret加1
2. dp[i-1] < num <= dp[i], 只更新相应的dp[i]
*/

class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {

    	int n = nums.size();
    	if(n == 0)
    		return 0;
    	int ret = 0;
        vector<int> dp;
        for(int i = 0;i < n;i++) 
        {
        	if(ret == 0 || dp[ret-1] < nums[i])
        	{
        		dp.push_back(nums[i]);
        		ret++;
        	}
			else        
			{   
				bool flag = false;
				int l = 0;
				int h = ret-1;
			    while(l <= h) 
			    {
	                int mid = l+(h-l)/2;
	                if(dp[mid] == nums[i])
	                {
	                	flag = true;
	                	break;
	                }
	                else if(dp[mid] < nums[i])
	                    l = mid+1;
	                else
	                    h = mid-1;
                }
                if(!flag)
                	dp[l] = nums[i];
            }
            
        }
        return ret;   
    }

};


