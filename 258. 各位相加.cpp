给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。

示例:

输入: 38
输出: 2 
解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。
进阶:
你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？


//直接法
class Solution {
public:
    int addDigits(int num) {

    	int cur = num;
    	while(cur/10 != 0)
    	{
    		int next = 0;
    		while(cur!=0)
    		{
    			next+=cur%10;
    			cur = cur/10;
    		}
    		cur = next;
    	}
    	return cur;
        
    }
};


/*我们可以找找规律

0的结果是1

1 的结果是 1
2 的结果是 2
3 的结果是 3
4 的结果是 4
5 的结果是 5
6 的结果是 6
7 的结果是 7
8 的结果是 8
9 的结果是 9

10 的结果是 1
11 的结果是 2
12 的结果是 3
13 的结果是 4
14 的结果是 5
15 的结果是 6
16 的结果是 7
17 的结果是 8
18 的结果是 9

19 的结果是 1
20 的结果是 2
21 的结果是 3
22 的结果是 4
23 的结果是 5
24 的结果是 6
25 的结果是 7
26 的结果是 8
27 的结果是 9

28 的结果是 1
29 的结果是 2
。。。

 
可以发现从1开始周期为9
但是要注意当num == 0的时候会输出0
num % 9 == 0得到9(这里num是从下标从1开始的第几个数)
*/
class Solution {
public:
    int addDigits(int num) {

    	if(num == 0)
    		return 0;
    	if(num%9 == 0)
    		return 9;
    	else 
    		return num%9;       
    }
};

//或者另一种解释
/*
除了传统的单纯循环，还可以找规律。
假如一个三位数'abc'，
其值大小为n = 100 * a + 10 * b + 1 * c，
经过一次各位相加后，变为addn = a + b + c，
减小的差值为(s1 -s2) = 99 * a + 9 * b,
差值可以被9整除，每一个循环都这样，缩小了9的倍数
取余的原理：
说明n和addn对于9，即n%9 == (addn+9的倍数)%9 == addn%9 
那么变化到最后的个位数(1-9)取余的结果也就是n%9(我们这里
要注意如果最后得到的各位数是9，那么取余的结果就是0)
*/
class Solution {
public:
    int addDigits(int num) {

    	if(num < 10)
    		return num;
    	if(num%9 == 0)
    		return 9;
    	else 
    		return num%9;       
    }
};